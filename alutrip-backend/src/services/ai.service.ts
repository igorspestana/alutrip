import Groq from 'groq-sdk';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { logger } from '../config/logger';
import { config } from '../config/env';
import { AIModel, AIServiceResponse } from '../types/travel';
import { 
  TRAVEL_KEYWORDS, 
  NON_TRAVEL_KEYWORDS 
} from '../constants/keywords';
import axios from 'axios';

/**
 * AI Service for integrating with multiple providers (Groq and Gemini)
 * Handles travel-related question processing and response generation
 */
export class AIService {
  private groqClient: Groq;
  private geminiAI: GoogleGenerativeAI;
  
  constructor() {
    // Initialize Groq SDK
    this.groqClient = new Groq({
      apiKey: config.GROQ_API_KEY,
    });
    
    // Initialize Gemini AI
    this.geminiAI = new GoogleGenerativeAI(config.GEMINI_API_KEY);
  }

  /**
   * Process a travel question using the specified AI model
   */
  async processQuestion(
    question: string, 
    model: AIModel,
    sessionId?: string
  ): Promise<AIServiceResponse> {
    const startTime = Date.now();
    
    try {
      logger.info('Starting AI question processing', {
        context: 'ai',
        model,
        questionLength: question.length,
        sessionId
      });

      // First, check if the question is travel-related
      const isTravelRelated = this.isTravelRelatedQuestion(question);
      
      if (!isTravelRelated) {
        logger.info('Question filtered as non-travel related', {
          context: 'ai',
          model,
          question: question.substring(0, 100) + '...',
          sessionId
        });

        // Return a polite decline response without using AI
        const declineMessage = 
          'Ol√°! Eu sou o AluTrip, seu assistente de viagem! Eu estou aqui para ajudar voc√™ com tudo que envolve destinos, hospedagens, passeios, restaurantes e dicas de viagem. ' +
          'Essa pergunta que voc√™ fez foge um pouquinho do tema de viagens, mas se quiser, pode me mandar uma d√∫vida sobre sua pr√≥xima aventura que vou adorar ajudar!';
        
        return {
          content: declineMessage,
          model_used: model,
          token_usage: {
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0
          },
          processing_time_ms: Date.now() - startTime
        };
      }
      
      let response: AIServiceResponse;
      
      switch (model) {
      case 'groq':
        response = await this.processWithGroq(question, sessionId);
        break;
      case 'gemini':
        response = await this.processWithGemini(question, sessionId);
        break;
      default:
        throw new Error(`Unsupported AI model: ${model}`);
      }
      
      const totalTime = Date.now() - startTime;
      
      logger.info('AI question processing completed', {
        context: 'ai',
        model,
        processingTime: `${totalTime}ms`,
        responseLength: response.content.length,
        sessionId
      });
      
      return {
        ...response,
        processing_time_ms: totalTime
      };
      
    } catch (error) {
      const totalTime = Date.now() - startTime;
      
      logger.error('AI question processing failed', {
        context: 'ai',
        model,
        error: (error as Error).message,
        processingTime: `${totalTime}ms`,
        sessionId
      });
      
      // Create AI service specific error
      const aiError = new Error(
        `Failed to process question with ${model}: ${(error as Error).message}`
      ) as Error & { provider: string; status?: number; code?: string };
      aiError.provider = model;
      
      // Add specific error codes if available
      if (axios.isAxiosError(error)) {
        if (error.response?.status) {
          aiError.status = error.response.status;
        }
        if (error.code) {
          aiError.code = error.code;
        }
      }
      
      throw aiError;
    }
  }

  /**
   * Process question using Groq (Llama model)
   */
  private async processWithGroq(question: string, sessionId?: string): Promise<AIServiceResponse> {
    try {
      const prompt = this.buildTravelPrompt(question);
      
      const chatCompletion = await this.groqClient.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: this.getSystemPrompt()
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        model: config.GROQ_MODEL,
        temperature: 0.7,
        max_tokens: 1024,
        top_p: 1,
        stream: false,
        stop: null
      });

      const response = chatCompletion.choices[0]?.message?.content || '';
      
      if (!response.trim()) {
        throw new Error('Empty response from Groq API');
      }

      return {
        content: response.trim(),
        model_used: 'groq',
        token_usage: chatCompletion.usage ? {
          prompt_tokens: chatCompletion.usage.prompt_tokens || 0,
          completion_tokens: chatCompletion.usage.completion_tokens || 0,
          total_tokens: chatCompletion.usage.total_tokens || 0
        } : {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        },
        processing_time_ms: 0 // Will be set by parent method
      };
      
    } catch (error) {
      logger.error('Groq processing failed', {
        context: 'ai',
        error: (error as Error).message,
        sessionId
      });
      throw error;
    }
  }

  /**
   * Process question using Google Gemini
   */
  private async processWithGemini(question: string, sessionId?: string): Promise<AIServiceResponse> {
    try {
      const model = this.geminiAI.getGenerativeModel({ model: config.GEMINI_MODEL });
      
      const prompt = `${this.getSystemPrompt()}\n\nUser Question: ${this.buildTravelPrompt(question)}`;
      
      const result = await model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      
      if (!text.trim()) {
        throw new Error('Empty response from Gemini API');
      }

      return {
        content: text.trim(),
        model_used: 'gemini',
        token_usage: {
          prompt_tokens: 0, // Gemini doesn't provide token usage details in current SDK
          completion_tokens: 0,
          total_tokens: 0
        },
        processing_time_ms: 0 // Will be set by parent method
      };
      
    } catch (error) {
      logger.error('Gemini processing failed', {
        context: 'ai',
        error: (error as Error).message,
        sessionId
      });
      throw error;
    }
  }

  /**
   * Check if a question is travel-related using simple keyword analysis
   * Prioritizes usability by being permissive rather than restrictive
   */
  private isTravelRelatedQuestion(question: string): boolean {
    const lowerQuestion = question.toLowerCase().trim();
    
    // If question is too short or empty, reject
    if (lowerQuestion.length < 3) {
      return false;
    }
    
    // Count travel-related keywords
    const travelScore = TRAVEL_KEYWORDS.reduce((score, keyword) => {
      return score + (lowerQuestion.includes(keyword) ? 1 : 0);
    }, 0);
    
    // Count non-travel keywords
    const nonTravelScore = NON_TRAVEL_KEYWORDS.reduce((score, keyword) => {
      return score + (lowerQuestion.includes(keyword) ? 1 : 0);
    }, 0);
    
    // BALANCED DECISION LOGIC - Balance usability with proper filtering
    
    // 1. If there are travel keywords, always allow
    if (travelScore > 0) {
      logger.info('Question accepted: travel keywords detected', {
        context: 'ai',
        travelScore,
        nonTravelScore,
        question: question.substring(0, 100)
      });
      return true;
    }
    
    // 2. Reject if there are non-travel keywords (even just one) AND no travel keywords
    if (nonTravelScore > 0 && travelScore === 0) {
      logger.info('Question rejected: non-travel keywords without travel context', {
        context: 'ai',
        nonTravelScore,
        travelScore,
        question: question.substring(0, 100)
      });
      return false;
    }
    
    // 3. Default to accepting questions for better usability (only when no clear indicators)
    logger.info('Question accepted: default acceptance for usability', {
      context: 'ai',
      travelScore,
      nonTravelScore,
      question: question.substring(0, 100)
    });
    return true;
  }

  /**
   * Build travel-specific prompt with context
   */
  private buildTravelPrompt(question: string): string {
    return `
Pergunta sobre Viagem: ${question}

Por favor, forne√ßa uma resposta abrangente e √∫til sobre esta pergunta relacionada a viagens.
Inclua recomenda√ß√µes espec√≠ficas, dicas pr√°ticas e detalhes relevantes que seriam valiosos 
para o planejamento da viagem.
Se a pergunta envolve destinos, inclua informa√ß√µes sobre melhores √©pocas para visitar, 
costumes locais, considera√ß√µes de or√ßamento e atra√ß√µes imperd√≠veis.
Mantenha a resposta informativa, mas concisa, focando em conselhos pr√°ticos de viagem.
`;
  }

  /**
   * Get system prompt for travel assistant with strict guardrails
   */
  private getSystemPrompt(): string {
    const basePrompt = `Voc√™ √© o AluTrip, um assistente de viagem especializado em IA que ajuda as pessoas a 
planejar viagens incr√≠veis sem burocracia ou barreiras.

üö® REGRAS CR√çTICAS E OBRIGAT√ìRIAS üö®

1. VOC√ä DEVE responder APENAS e EXCLUSIVAMENTE a perguntas relacionadas a:
   - Destinos tur√≠sticos e lugares para visitar
   - Planejamento de viagens e itiner√°rios
   - Hospedagem (hot√©is, pousadas, resorts, etc.)
   - Transporte (voos, trens, √¥nibus, carros, etc.)
   - Atividades tur√≠sticas e passeios
   - Restaurantes e gastronomia local
   - Dicas de viagem e prepara√ß√£o
   - Cultura local e costumes
   - Seguran√ßa em viagens
   - Documenta√ß√£o necess√°ria (passaporte, visto, etc.)
   - Or√ßamento e custos de viagem
   - Melhor √©poca para viajar
   - O que levar na mala

2. SE A PERGUNTA N√ÉO FOR SOBRE VIAGEM, voc√™ DEVE:
   - Imediatamente recusar responder
   - Usar EXATAMENTE a mensagem padr√£o de recusa
   - N√ÉO dar nenhuma informa√ß√£o sobre o t√≥pico perguntado
   - N√ÉO tentar ajudar com o assunto n√£o relacionado a viagem

3. T√ìPICOS PROIBIDOS (N√ÉO RESPONDA):
   - Tecnologia, programa√ß√£o, software, IA, desenvolvimento
   - Sa√∫de, medicina, sintomas, tratamentos, medicamentos
   - Quest√µes legais, advogados, processos, contratos
   - Finan√ßas, investimentos, criptomoedas, bancos
   - Pol√≠tica, elei√ß√µes, governo, economia
   - Relacionamentos, namoro, casamento, fam√≠lia
   - Educa√ß√£o, estudos, cursos, universidades
   - Esportes (exceto se relacionado a viagem)
   - Entretenimento (filmes, s√©ries, m√∫sica - exceto se relacionado a viagem)
   - Trabalho, carreira, empregos
   - Qualquer assunto que n√£o seja diretamente sobre viagem`;

    const refusalMessage = `4. MENSAGEM OBRIGAT√ìRIA DE RECUSA:
   "Ol√°! Eu sou o AluTrip, seu assistente de viagem! Eu estou aqui para ajudar voc√™ com tudo que envolve destinos, hospedagens, passeios, restaurantes e dicas de viagem. Essa pergunta que voc√™ fez foge um pouquinho do tema de viagens, mas se quiser, pode me mandar uma d√∫vida sobre sua pr√≥xima aventura que vou adorar ajudar!"`;

    const validationRules = `5. VALIDA√á√ÉO OBRIGAT√ìRIA:
   - Antes de responder, SEMPRE analise se a pergunta √© sobre viagem
   - Se houver D√öVIDA, prefira recusar a responder
   - Seja EXTREMAMENTE restritivo - √© melhor recusar uma pergunta v√°lida do que responder uma inv√°lida

Seu papel (APENAS para perguntas sobre viagem):
- Fornecer conselhos de viagem precisos, √∫teis e personalizados
- Compartilhar dicas pr√°ticas sobre destinos, hospedagens, transporte e atividades
- Considerar or√ßamento, tempo e prefer√™ncias pessoais em suas recomenda√ß√µes
- Oferecer conhecimento sobre costumes locais, melhores √©pocas para visitar
- Ajudar com planejamento de itiner√°rio, sugest√µes de bagagem e log√≠stica
- Ser entusiasmado e encorajador, mas realista sobre as expectativas

Diretrizes para respostas sobre viagem:
- Sempre seja √∫til, amig√°vel e encorajador
- Forne√ßa conselhos espec√≠ficos e acion√°veis
- Inclua detalhes pr√°ticos como custos aproximados, hor√°rios e dicas de reserva
- Mencione desafios potenciais ou considera√ß√µes importantes
- Sugira alternativas quando apropriado
- Mantenha as respostas abrangentes, mas n√£o esmagadoras
- Use um tom conversacional e acess√≠vel

LEMBRE-SE: Sua fun√ß√£o √© SER UM ASSISTENTE DE VIAGEM. Qualquer pergunta que n√£o seja sobre viagem deve ser recusada imediatamente com a mensagem padr√£o.`;

    return `${basePrompt} ${refusalMessage} ${validationRules}`;
  }

  /**
   * Health check for AI services
   */
  async healthCheck(): Promise<{
    groq: { status: 'healthy' | 'unhealthy'; error?: string };
    gemini: { status: 'healthy' | 'unhealthy'; error?: string };
  }> {
    const results: {
      groq: { status: 'healthy' | 'unhealthy'; error?: string };
      gemini: { status: 'healthy' | 'unhealthy'; error?: string };
    } = {
      groq: { status: 'unhealthy' },
      gemini: { status: 'unhealthy' }
    };

    // Test Groq
    try {
      await this.groqClient.chat.completions.create({
        messages: [{ role: 'user', content: 'Hello' }],
        model: config.GROQ_MODEL,
        max_tokens: 5
      });
      results.groq.status = 'healthy';
    } catch (error) {
      results.groq.error = (error as Error).message;
    }

    // Test Gemini
    try {
      const model = this.geminiAI.getGenerativeModel({ model: config.GEMINI_MODEL });
      await model.generateContent('Hello');
      results.gemini.status = 'healthy';
    } catch (error) {
      results.gemini.error = (error as Error).message;
    }

    return results;
  }

  /**
   * Get model availability and configuration
   */
  getModelInfo(): {
    groq: { model: string; available: boolean };
    gemini: { model: string; available: boolean };
    } {
    return {
      groq: {
        model: config.GROQ_MODEL,
        available: !config.GROQ_API_KEY.includes('your-groq-api-key')
      },
      gemini: {
        model: config.GEMINI_MODEL,
        available: !config.GEMINI_API_KEY.includes('your-gemini-api-key')
      }
    };
  }
}

// Export singleton instance
export const aiService = new AIService();
